"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore
const axios_1 = __importDefault(require("axios"));
const _global = global;
_global.createRequestManager = function (info) {
    return {
        ...info,
        schedule: async function (request, retryCount) {
            // Pass this request through the interceptor if one exists
            if (info.interceptor) {
                request = await info.interceptor.interceptRequest(request);
            }
            // Append any cookies into the header properly
            let headers = request.headers ?? {};
            let cookieData = '';
            for (let cookie of request.cookies ?? [])
                cookieData += `${cookie.name}=${cookie.value};`;
            headers['cookie'] = cookieData;
            // If no user agent has been supplied, default to a basic Paperback-iOS agent
            headers['user-agent'] = headers["user-agent"] ?? 'Paperback-iOS';
            // If we are using a urlencoded form data as a post body, we need to decode the request for Axios
            let decodedData = request.data;
            if (typeof decodedData == 'object') {
                if (headers['content-type']?.includes('application/x-www-form-urlencoded')) {
                    decodedData = "";
                    Object.keys(request.data).forEach(attribute => {
                        if (decodedData.length > 0) {
                            decodedData += "&";
                        }
                        decodedData += `${attribute}=${request.data[attribute]}`;
                    });
                }
            }
            // We must first get the response object from Axios, and then transcribe it into our own Response type before returning
            let response = await (0, axios_1.default)(`${request.url}${request.param ?? ''}`, {
                method: request.method,
                headers: headers,
                data: decodedData,
                timeout: info.requestTimeout || 0,
                responseType: 'arraybuffer'
            });
            let responsePacked = {
                rawData: createRawData(response.data),
                data: Buffer.from(response.data, 'binary').toString(),
                status: response.status,
                headers: response.headers,
                request: request
            };
            // Pass this through the response interceptor if one exists
            if (info.interceptor) {
                responsePacked = await info.interceptor.interceptResponse(responsePacked);
            }
            return responsePacked;
        }
    };
};
